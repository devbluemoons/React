## 컴포넌트 성능 최적화  
  
컴포넌트는 다음과 같은 상황에서 리렌더링이 발생한다  
  
1. 자신이 전달받은 props가 변경될 때
1. 자신의 state가 바뀔 때
1. 부모 컴포넌트가 리렌더링될 때
1. forceUpdate 함수가 실행될 때  
  
리렌더링이 불필요할 때는 리렌더링을 방지해 주어야 한다  
  
함수형 컴포넌트에서는 `라이프사이클 메서드`를 사용할 수 없다 그대신 `React.memo`라는 함수를 사용  
  
`React.memo`를 사용하여 컴포넌트를 감싸 주기만 하면 된다  
  
```jsx
import React from 'react';

const TodoListItem = () => {
  (...)
}

export default React.memo(TodoListItem);
```
  
### `useState`의 함수형 업데이트
  
```jsx
const [number, setNumber] = useState(0);
const onIncrease = useCallback(
  () => setNumber(prevNumber => prevNumber + 1), 
  [],
);
```  
  
위 코드처럼 `어떻게 업데이트할지 정의해 주는 업데이트 함수`를 넣어 준다
  
그러면 `useCallback`을 사용할 때 두 번째 파라미터로 넣는 배열에 number를 넣지 않아도 된다  
  
---
  
### 불변성의 중요성
  
리액트 컴포넌트에서 `상태를 업데이트할 때` 불변성을 지키는 것이 매우 중요하다  
  
기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 `불변성을 지킨다`고 한다  
  
불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못한다  
  
그러면 `React.memo`에서 서로 비교하여 최적화하는 것이 불가능하다  
  
`전개 연산자(...)`를 사용하여 객체나 배열 내부의 값을 복사할 때는 얕은 복사(shallow copy)를 하게 된다  
  
즉 내부의 값이 완전히 새로 복사되는 것이 아니라 `가장 바깥쪽에 있는 값만 복사`됩니다  
  
따라서 내부의 값이 객체 혹은 배열이라면 내부의 값 또한 따로 복사해 주어야 한다  
  
